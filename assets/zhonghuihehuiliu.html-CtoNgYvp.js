import{_ as s,c as a,a as p,o as t}from"./app-Crz_P5Al.js";const e={};function o(l,n){return t(),a("div",null,n[0]||(n[0]=[p(`<h3 id="回流" tabindex="-1"><a class="header-anchor" href="#回流"><span>回流</span></a></h3><p>浏览器计算页面布局的过程就叫做 <code>回流</code></p><p>只要页面有容器几何信息发生变更就会发生回流，也就是影响了它的排版，所以回流太常见了，有以下几种：</p><ol><li>改变窗口的尺寸</li><li>改变元素的尺寸</li><li>display: none | block;（增加或删除可见元素）</li><li>页面初次渲染</li></ol><p><strong>容器脱离文档流是不会发生回流</strong>，当然这是针对影响其他元素而言，比如你增删一个可见元素，是会影响下面容器的几何信息的。对于脱离文档流容器本身而言，肯定是发生回流的</p><h3 id="重绘" tabindex="-1"><a class="header-anchor" href="#重绘"><span>重绘</span></a></h3><p>GPU将已经计算好几何信息的容器在屏幕上亮起来就是 <code>重绘</code></p><p>所以只要元素的非几何属性发生变化时，就会发生重绘</p><ol><li>修改背景颜色</li><li>修改背景图片</li><li>边框颜色</li><li>字体颜色</li><li>回流</li></ol><p>注意，既然发生了回流，就一定会带来重绘，重绘不一定带来回流</p><h3 id="如何减少回流-重绘" tabindex="-1"><a class="header-anchor" href="#如何减少回流-重绘"><span>如何减少回流，重绘</span></a></h3><blockquote><p>回流重绘这两个过程回流因为涉及到计算，所以它开销的性能会更多</p></blockquote><p>相比较以前的浏览器，现在的浏览器是有一个优化策略的，它执行js的时候会维护一个渲染队列，改变一个容器的样式，导致需要发生回流的时候，这个操作会进入渲染队列，如果还有相同行为，继续进入队列，直到下面没有样式修改，浏览器会批量化地执行渲染队列中的回流过程，这只发生一次回流，所以说，我们为了减少回流，重绘，可以合理利用浏览器的优化策略，少去读取几何信息，或者统一放到最后读取</p><h4 id="none-block优化" tabindex="-1"><a class="header-anchor" href="#none-block优化"><span>none，block优化</span></a></h4><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span></span>
<span class="line">    <span class="token keyword">const</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;box&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    ul<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">&quot;none&quot;</span><span class="token punctuation">;</span> </span>
<span class="line">  </span>
<span class="line">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">let</span> li <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;li&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">let</span> text <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">// 创建文本节点</span></span>
<span class="line">        li<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span> </span>
<span class="line">        ul<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 100次</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    ul<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">&quot;block&quot;</span>  </span>
<span class="line"><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就是两次回流了</p><h4 id="fragment文档碎片优化" tabindex="-1"><a class="header-anchor" href="#fragment文档碎片优化"><span>Fragment文档碎片优化</span></a></h4><p>Fragment是一种机制，用于在内存中创建一个轻量级的文档碎片，这个文档碎片可以包含多个节点，它不涉及dom结构的实际插入，因此不会触发回流，最后带有批量节点的文档碎片插入到文档中，这样可以减少回流的次数</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span></span>
<span class="line">    <span class="token keyword">const</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;box&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">const</span> fragment <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 虚拟的文档片段</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">let</span> li <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;li&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">let</span> text <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> </span>
<span class="line">        li<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span></span>
<span class="line">        fragment<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 虚拟片段不会回流</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    ul<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>fragment<span class="token punctuation">)</span> </span>
<span class="line"><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就只会引起一次回流</p><h4 id="clone克隆优化" tabindex="-1"><a class="header-anchor" href="#clone克隆优化"><span>clone克隆优化</span></a></h4><p>这里的克隆是克隆节点，克隆过程发生在内存中，不会影响到文档布局，因此我们对副本进行操作，不引起回流，并且克隆是深拷贝，不会影响原体，克隆节点插入到文档中才会引起回流</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span></span>
<span class="line">    <span class="token keyword">const</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;box&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">const</span> clone <span class="token operator">=</span> ul<span class="token punctuation">.</span><span class="token function">cloneNode</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// 克隆一份ul，必定是深拷贝，原ul不受影响</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">let</span> li <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;li&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">let</span> text <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">// 创建文本节点</span></span>
<span class="line">        li<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span></span>
<span class="line">        clone<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    ul<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">replaceChild</span><span class="token punctuation">(</span>clone<span class="token punctuation">,</span> ul<span class="token punctuation">)</span> <span class="token comment">// (替代品, 被替代品)</span></span>
<span class="line"><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样只会引起一次回流</p>`,24)]))}const i=s(e,[["render",o],["__file","zhonghuihehuiliu.html.vue"]]),u=JSON.parse('{"path":"/blogs/Css/2025/zhonghuihehuiliu.html","title":"重绘和回流","lang":"en-US","frontmatter":{"title":"重绘和回流","date":"2025/4/18","tags":["重绘和回流"],"categories":["CSS"]},"headers":[{"level":3,"title":"回流","slug":"回流","link":"#回流","children":[]},{"level":3,"title":"重绘","slug":"重绘","link":"#重绘","children":[]},{"level":3,"title":"如何减少回流，重绘","slug":"如何减少回流-重绘","link":"#如何减少回流-重绘","children":[]}],"git":{"createdTime":1757911599000,"updatedTime":1757911599000,"contributors":[{"name":"D_quieT","email":"1360577536@qq.com","commits":1}]},"filePathRelative":"blogs/Css/2025/重绘和回流.md"}');export{i as comp,u as data};
